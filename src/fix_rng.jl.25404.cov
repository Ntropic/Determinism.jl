        - using Random
        - using SHA
        - const rand_funs = [:rand, :randi, :randn, :randexp, :randperm, :randstring]
        - 
       11 function extract_variable_names(loop_var)
       11     if isa(loop_var, Expr)
        0         if loop_var.head == :tuple
        -             # If it's a tuple, extract each variable
        0             return [extract_variable_names(arg) for arg in loop_var.args]
        0         elseif loop_var.head == :(=)
        -             # If it's an assignment, extract the variable name
        0             return extract_variable_names(loop_var.args[1])
        -         end
       11     elseif isa(loop_var, Symbol)
        -         # If it's a single variable, return it
       11         return loop_var
        -     end
        0     return nothing
        - end
       11 function separate_for_block(for_expr::Expr)
        -     # Check if it's a 'for' loop
       11     if for_expr.head == :for
        -         # The first two arguments are the loop variable and range
       11         args = for_expr.args[1]
        -         # The third argument is the body (or block of code)
       11         body = for_expr.args[2]  # It should exist as long as the loop has a body
       11         if length(for_expr.args) != 2
        0             throw(ArgumentError("Block has wrong number of arguments"))
        -         end
       11         varargs = extract_variable_names(args.args[1])
       11         return varargs, args, body
        -     else
        0         throw(ArgumentError("Expression is not a for loop"))
        -     end
        - end
        - 
       64 function is_for_block(expr)
        -     # check first if is a Expr 
       64     if isa(expr, Expr) 
       64         return expr.head == :for
        -     else
        0         false 
        -     end
        - end
        - function contains_for_block(expr)
        -     if !isa(expr, Expr) 
        -         return false 
        -     end
        - 
        -     # First, check if the current expression is a for-loop
        -     if is_for_block(expr)
        -         return true
        -     end
        - 
        -     # Recursively check in all subexpressions
        -     for arg in expr.args
        -         if arg isa Expr
        -             if contains_for_block(arg)  # Check in the sub-expression
        -                 return true
        -             end
        -         end
        -     end
        -     return false
        - end
        - 
        3 function extract_macro_symbol(expr)
        6     if isa(expr.args[1], Expr) && expr.args[1].head == :(.)
        -         # Extract the last argument of the dotted expression
        3         node = expr.args[1].args[end]
        3         return isa(node, QuoteNode) ? node.value : node
        0     elseif isa(expr.args[1], Symbol)
        -         # Direct symbol case (e.g., @floop)
        0         return expr.args[1]
        -     else
        0         throw(ArgumentError("Unexpected macro expression structure"))
        -     end
        - end
        - 
      335 function fix_rng(expr, new_rng_var::Symbol=:rng, old_rng_var::Symbol=:rng, symbols::Vector{Symbol}=Symbol[], hash_int::Int=0, in_parallel_macro::Bool=false)
        -     # Base case: if it's not an expression, replace old_rng_var with new_rng_var if necessary
      335     if !isa(expr, Expr)
      150         return expr == old_rng_var ? new_rng_var : expr
        -     end 
        - 
        -     # Handle macro calls (e.g., @threads, @sync)
       67     if expr.head == :macrocall
        3         macro_name = extract_macro_symbol(expr)
       12         parallel_macros = [Symbol("@threads"), Symbol("@distributed"), Symbol("@parallel"), Symbol("@floop")]
        3         if macro_name in parallel_macros
        -             # Recursively process the macro body, indicating it's inside a parallel macro
        3             expr.args[end] = fix_rng(expr.args[end], new_rng_var, old_rng_var, symbols, hash_int, true)
        -         else
        -             # Process the macro body without marking it as parallel
        0             expr.args[end] = fix_rng(expr.args[end], new_rng_var, old_rng_var, symbols, hash_int)
        -         end
        3         return expr
        -     end
        - 
        -     # Handle `for` loops
       64     if is_for_block(expr)
       11         curr_symbols = copy(symbols)
       11         loop_var, other_args, body = separate_for_block(expr)
        - 
        -         # Track loop variables
       11         if loop_var isa Vector
        0             append!(curr_symbols, loop_var)
       11         elseif loop_var isa Symbol
       11             push!(curr_symbols, loop_var)
        -         end
        - 
        -         # If inside a parallel macro, generate a new RNG per iteration
       11         if in_parallel_macro
        3             rng_symbol = gensym(:rng)
        3             if length(curr_symbols) > 0
        3                 if hash_int > 0
        1                     rng_expr = :( $rng_symbol = MersenneTwister(hash($(Expr(:tuple, curr_symbols...)))+$hash_int) ) 
        -                 else
        2                     rng_expr = :( $rng_symbol = MersenneTwister(hash($(Expr(:tuple, curr_symbols...)))) ) 
        -                 end
        -             else
        0                 rng_expr = :( $rng_symbol = MersenneTwister(hash($hash_int)) )
        -             end
        3             new_body = fix_rng(body, rng_symbol, old_rng_var, curr_symbols, hash_int)
        3             return Expr(:for, other_args, Expr(:block, rng_expr, new_body.args...))
        -         else
        -             # Non-parallel `for` loops: process the body as-is
        8             return Expr(:for, other_args, fix_rng(body, new_rng_var, old_rng_var, curr_symbols, hash_int))
        -         end
        -     end
        - 
        -     # Handle `while` loops
       53     if expr.head == :while
        0         return Expr(:while, map(x -> fix_rng(x, new_rng_var, old_rng_var, symbols, hash_int), expr.args)...)
        -     end
        - 
        -     # Handle function calls
       53     if expr.head == :call
       48         processed_args = map(arg -> fix_rng(arg, new_rng_var, old_rng_var, symbols, hash_int), expr.args)
       19         if processed_args[1] in rand_funs
       42             updated_args = map(x -> x == old_rng_var ? new_rng_var : x, processed_args)
        9             if new_rng_var in updated_args[2:end]
        3                 return Expr(:call, updated_args...)
        -             else
        6                 return Expr(:call, processed_args[1], new_rng_var, updated_args[2:end]...)
        -             end
        -         else
        5             return Expr(:call, processed_args...)
        -         end
        -     end
        - 
        -     # Recursively process all arguments for other expression types
      156     return Expr(expr.head, map(x -> fix_rng(x, new_rng_var, old_rng_var, symbols, hash_int), expr.args)...)
        - end
        - 
        8 function add_twister_if_undefined(rng_var::Symbol, hash_int::Int=0)
        -     # Generate the conditional `if` expression
        8     return :(if !(Base.@isdefined $(rng_var))
        2                 $rng_var = MersenneTwister($hash_int)
        -             end)
        - end
        8 function fix_rng_with_twister(expr::Expr, rng_var::Symbol, hash_int::Int)
        -     # Add the Twister initialization if the RNG variable is not defined
        8     rng_check_expr = add_twister_if_undefined(rng_var, hash_int)
        - 
        -     # Process the input expression using `fix_rng`
        8     fixed_expr = fix_rng(expr, rng_var, rng_var, Symbol[], hash_int, false)
        -     # Combine the Twister initialization and the transformed expression
        8     return esc(Expr(:block, rng_check_expr, fixed_expr))
        - end
        - 
        1 macro determinism(expr::Expr)
        1     rng_var::Symbol = :rng
        1     hash_int::Int = 0
        1     new_expr = fix_rng_with_twister(expr, rng_var, hash_int)
        1     return new_expr
        - end
        - 
        - macro determinism(rng_var::Symbol, expr::Expr)
        -     hash_int::Int = 0
        -     return fix_rng_with_twister(expr, rng_var, hash_int)
        - end
        - 
        - macro determinism(hash_int::Int, expr::Expr)
        -     rng_var::Symbol = :rng
        -     return fix_rng_with_twister(expr, rng_var, hash_int)
        - end
        - 
        7 macro determinism(rng_var::Symbol, hash_int::Int, expr::Expr)
        7     return fix_rng_with_twister(expr, rng_var, hash_int)
        - end
